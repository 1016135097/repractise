<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>RePractise - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css">
  <meta name="viewport" content="width=device-width">
</head>
<body>

<p>
	<h1>RePractise</h1>
	<h3>By Phodal Huang(<a href="http://www.phodal.com">Geek's Life</a>)</h3>
</p>
<div>

<iframe src="http://ghbtns.com/github-btn.html?user=phodal&repo=repractise&type=watch&count=true"
  allowtransparency="true" frameborder="0" scrolling="0" width="110px" height="20px"></iframe>
<div>
<nav id="TOC">
<ul>
<li><a href="#引言">引言</a><ul>
<li><a href="#re-practise">Re-Practise</a></li>
<li><a href="#技术与业务">技术与业务</a></li>
<li><a href="#资讯爆炸">资讯爆炸</a></li>
<li><a href="#结">结</a></li>
</ul></li>
<li><a href="#lost">Lost</a></li>
<li><a href="#介绍">介绍</a></li>
<li><a href="#构建篇build">构建篇：Build</a></li>
<li><a href="#repractise前端篇-前端演进史">RePractise前端篇: 前端演进史</a><ul>
<li><a href="#什么是前端">什么是前端？</a></li>
<li><a href="#前端演进史">前端演进史</a><ul>
<li><a href="#数据-模板-样式混合">数据-模板-样式混合</a></li>
<li><a href="#model-view-controller">Model-View-Controller</a></li>
<li><a href="#从桌面版到移动版">从桌面版到移动版</a></li>
<li><a href="#app与过渡期api">APP与过渡期API</a></li>
<li><a href="#过渡期spa">过渡期SPA</a></li>
<li><a href="#hybird与viewmodel">Hybird与ViewModel</a></li>
<li><a href="#一次构建跨平台运行">一次构建，跨平台运行</a></li>
</ul></li>
<li><a href="#repractise">RePractise</a></li>
</ul></li>
<li><a href="#repractise前端篇-数据-表现-领域">RePractise前端篇: 数据-表现-领域</a><ul>
<li><a href="#数据">数据</a><ul>
<li><a href="#数据库">数据库</a></li>
</ul></li>
</ul></li>
<li><a href="#易读">易读</a></li>
</ul>
</nav>
<h1 id="引言">引言</h1>
<p>回到一年前的今天(2014.09.29)，一边在准备着去沙漠之旅，一边在准备国庆后的印度培训。</p>
<p>当时我还在用我的Lumia 920，上面没有各式各样的软件，除了我最需要的地图、相机。所以，我需要为我的手机写一个应用，用于在地图上显示图片信息及照片。</p>
<p>今天Github已经可以支持geojson了，于是你可以看到我在之前生成的geojson在地图上的效果<a href="https://github.com/phodal-archive/onmap/blob/master/gps.geojson">gps.geojson</a>。</p>
<h2 id="re-practise">Re-Practise</h2>
<p>在过去的近一年时期里，花费了很多时间在提高代码质量与构建架构知识。试着学习某一方面的架构知识，应用到某个熟悉领域。</p>
<ol type="1">
<li><p>所谓的一万小时天才理论一直在说明练习的重要性，你需要不断地去练习。但是并不是说你练习了一万小时之后就可以让你成为一个专家，而练习是必须的。</p></li>
<li><p>让我想起了在大学时代学的PID算法，虽然我没有掌握好控制领域的相关理论及算法，但是我对各种调节还算有点印象。简单地来说，我们需要不断调整自己的方向。</p></li>
</ol>
<p>现在还存在的那些互联网公司或者说开源项目，我们会发现两个不算有趣的规律：</p>
<ol type="1">
<li>一个一直在运行的软件。</li>
<li>尝试了几个产品，最后找到了一个合适的方向。</li>
</ol>
<p>我发现我属于不断尝试地类型。一直想构建一个开源软件，但是似乎一直没有找对合理的用户？但是，我们会发现上述地两者都在不断地retry，不断地retry归根于那些人在不断的repractise。与之成为反例的便是：</p>
<ol type="1">
<li>一个成功发布几次的软件，但是最后失败了</li>
<li>尝试了不同的几个产品，但是失败了</li>
</ol>
<p>所谓的失败，就是你离开人世了。所以，在我们还活着的时候，我们总会有机会去尝试。在那之前，我们都是在不断地re-practise。</p>
<p>这让我想到了Linux，这算是一个不错地软件，从一开始就存活到了现在。但是有多少开源软件就没有这么幸运，时间在淘汰越来越多的过去想法。人们创造事物的能力也越来越强，但是那只是因为创造变得越来越简单。</p>
<p>在我们看到的那些走上人生巅峰的CEO，还都在不断地re-practise。</p>
<h2 id="技术与业务">技术与业务</h2>
<p>于是，我又再次回到了这样一个现实的问题。技术可以不断地练习，不断地调整方向。但是技术地成本在不断地降低，代码的长度在不断地降低。整个技术的门槛越来越低，新出现的技术总会让新生代的程序员获利。但是不可避免地，业务地复杂度并没有因此而降低。这就是一个复杂的话题，难道业务真的很复杂吗？</p>
<p>人们总会提及写好CSS很难，但是写好Java就是一件容易的事。因为每天我们都在用Java、JavaScript去写代码，但是我们并没有花费时间去学。</p>
<p>因为我们一直将我们的时候花费的所谓的业务上，我们可以不断地将一些重复的代码抽象成一个库。但是我们并没有花费过多的时间去整理我们的业务，作为程序员，我们切换工作很容易只是因为相同的技术栈。作为一些营销人员，他们从一个领域到一个新的领域，不需要过多的学习，因为本身是相通的。</p>
<p>技术本身是如此，业务本身也是如此。</p>
<p>从技术到业务是一条难走通的路？</p>
<h2 id="资讯爆炸">资讯爆炸</h2>
<p>回顾到最近出现的各种资讯程序——开发者头条、极客头条、掘金、博乐头条等等，他们帮助我们的是丰富我们的信息，而不是简化我们的信息。</p>
<p>作为一个开发人员，过去我们并不需要关注那么多的内容。如果我们没有关注那么多的点，那么我们就可以集中于我们的想法里。实现上，我们需要的是一个更智能的时代。</p>
<p>业务本身是一种重复，技术本身也是重复的。只是在某个特定的时刻，一个好的技术可以帮助我们更好地Re-Practise。如推荐算法本身依赖于人为对信息进行分类，但是我们需要去区分大量地信息。而人本身的经历是足够有险的，这时候就需要机器来帮我们做很多事。</p>
<h2 id="结">结</h2>
<p>今天我在用MX5，但是发现不及Lumia 1020来得安静。功能越强大的同时，意味着我在上面花费的时间会更多。事情有好的一面总会有不好的一面，不好的一面也就意味着有机会寻找好的一面。</p>
<p>我们需要摒弃一些东西，以重新纠正我们的方向。于是，我需要再次回到Lumia 1020上。</p>
<h1 id="lost">Lost</h1>
<blockquote>
<p>一开始就输在起跑线上</p>
</blockquote>
<blockquote>
<p>输了，才需要加倍努力</p>
</blockquote>
<h1 id="介绍">介绍</h1>
<h1 id="构建篇build">构建篇：Build</h1>
<p>构建是一个很大的话题，特别是对于传统软件来说，对于Web应用也是相当重要的。</p>
<p>关注微信公众号:</p>
<figure>
<img src="http://repractise.phodal.com/img/frontend/baimizhou.jpg" alt="Baimizhou" /><figcaption>Baimizhou</figcaption>
</figure>
<h1 id="repractise前端篇-前端演进史">RePractise前端篇: 前端演进史</h1>
<p>细细整理了过去接触过的那些前端技术，发现前端演进是段特别有意思的历史。人们总是在过去就做出未来需要的框架，而现在流行的是过去的过去发明过的。如，响应式设计不得不提到的一个缺点是：<strong>他只是将原本在模板层做的事，放到了样式（CSS）层来完成</strong>。</p>
<p>复杂度同力一样不会消失，也不会凭空产生，它总是从一个物体转移到另一个物体或一种形式转为另一种形式。</p>
<p>如果六、七年前的移动网络速度和今天一样快，那么直接上的技术就是响应式设计，APP、SPA就不会流行得这么快。尽管我们可以预见未来这些领域会变得更好，但是更需要的是改变现状。改变现状的同时也需要预见未来的需求。</p>
<h3 id="什么是前端">什么是前端？</h3>
<p>维基百科是这样说的：前端Front-end和后端back-end是描述进程开始和结束的通用词汇。前端作用于采集输入信息，后端进行处理。计算机程序的界面样式，视觉呈现属于前端。</p>
<p>这种说法给人一种很模糊的感觉，但是他说得又很对，它负责视觉展示。在MVC结构或者MVP中，负责视觉显示的部分只有View层，而今天大多数所谓的View层已经超越了View层。前端是一个很神奇的概念，但是而今的前端已经发生了很大的变化。</p>
<p>你引入了Backbone、Angluar，你的架构变成了MVP、MVVM。尽管发生了一些架构上的变化，但是项目的开发并没有因此而发生变化。这其中涉及到了一些职责的问题，如果某一个层级中有太多的职责，那么它是不是加重了一些人的负担？</p>
<h2 id="前端演进史">前端演进史</h2>
<p>过去一直想整理一篇文章来说说前端发展的历史，但是想着这些历史已经被人们所熟知。后来发现并非如此，大抵是幸存者偏见——关注到的都知道这些历史。</p>
<h3 id="数据-模板-样式混合">数据-模板-样式混合</h3>
<p>在有限的前端经验里，我还是经历了那段用Table来作样式的年代。大学期间曾经有偿帮一些公司或者个人开发、维护一些CMS，而Table是当时帮某个网站更新样式接触到的——ASP.Net（maybe)。当时，我们启动这个CMS用的是一个名为<code>aspweb.exe</code>的程序。于是，在我的移动硬盘里找到了下面的代码。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;TABLE</span><span class="ot"> cellSpacing=</span><span class="st">0</span><span class="ot"> cellPadding=</span><span class="st">0</span><span class="ot"> width=</span><span class="st">910</span><span class="ot"> align=</span><span class="st">center</span><span class="ot"> border=</span><span class="st">0</span><span class="kw">&gt;</span>
  <span class="kw">&lt;TBODY&gt;</span>
  <span class="kw">&lt;TR&gt;</span>
    <span class="kw">&lt;TD</span><span class="ot"> vAlign=</span><span class="st">top</span><span class="ot"> width=</span><span class="st">188</span><span class="kw">&gt;&lt;TABLE</span><span class="ot"> cellSpacing=</span><span class="st">0</span><span class="ot"> cellPadding=</span><span class="st">0</span><span class="ot"> width=</span><span class="st">184</span><span class="ot"> align=</span><span class="st">center</span><span class="ot"> border=</span><span class="st">0</span><span class="kw">&gt;</span>
        <span class="kw">&lt;TBODY&gt;</span>
        <span class="kw">&lt;TR&gt;</span>
          <span class="kw">&lt;TD&gt;&lt;IMG</span><span class="ot"> src=</span><span class="st">&quot;Images/xxx.gif&quot;</span><span class="ot"> width=</span><span class="st">184</span><span class="kw">&gt;&lt;/TD&gt;&lt;/TR&gt;</span>
        <span class="kw">&lt;TR&gt;</span>
          <span class="kw">&lt;TD&gt;</span>
            <span class="kw">&lt;TABLE</span><span class="ot"> cellSpacing=</span><span class="st">0</span><span class="ot"> cellPadding=</span><span class="st">0</span><span class="ot"> width=</span><span class="st">184</span><span class="ot"> align=</span><span class="st">center</span> 
<span class="ot">            background=</span><span class="st">Images/xxx.gif</span><span class="ot"> border=</span><span class="st">0</span><span class="kw">&gt;</span></code></pre></div>
<p>虽然，我也已经在HEAD里找到了现代的雏形——DIV + CSS，然而这仍然是一个Table的年代。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;LINK</span><span class="ot"> href=</span><span class="st">&quot;img/xxx.css&quot;</span><span class="ot"> type=</span><span class="st">text/css</span><span class="ot"> rel=</span><span class="st">stylesheet</span><span class="kw">&gt;</span></code></pre></div>
<p><strong>人们一直在说前端很难，问题是你学过么？？？</strong></p>
<p><strong>人们一直在说前端很难，问题是你学过么？？？</strong></p>
<p><strong>人们一直在说前端很难，问题是你学过么？？？</strong></p>
<p>也许，你也一直在说CSS不好写，但是CSS真的不好写么？人们总在说JS很难用，但是你学过么？只在需要的时候才去学，那肯定很难。<strong>你不曾花时间去学习一门语言，但是却能直接写出可以work的代码，说明他们容易上手</strong>。如果你看过一些有经验的Ruby、Scala、Emacs Lisp开发者写出来的代码，我想会得到相同的结论。有一些语言可以让写程序的人Happy，但是看的人可能就不Happy了。做事的方法不止一种，但是不是所有的人都要用那种方法去做。</p>
<p>过去的那些程序员都是<strong>真正的全栈程序员</strong>，这些程序员不仅仅做了前端的活，还做了数据库的工作。</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">Set</span> rs = Server.CreateObject(<span class="ot">&quot;ADODB.Recordset&quot;</span>)
sql = <span class="ot">&quot;select id,title,username,email,qq,adddate,content,Re_content,home,face,sex from Fl_Book where ispassed=1 order by id desc&quot;</span>
rs.open sql, Conn, <span class="dv">1</span>, <span class="dv">1</span>
fl.SqlQueryNum = fl.SqlQueryNum + <span class="dv">1</span></code></pre></div>
<p>在这个ASP文件里，它从数据库里查找出了数据，然后Render出HTML。如果可以看到历史版本，那么我想我会看到有一个作者将style=“”的代码一个个放到css文件中。</p>
<p>在这里的代码里也免不了有动态生成JavaScript代码的方法：</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">show_other <span class="op">=</span> <span class="st">&quot;&lt;SCRIPT language=javascript&gt;&quot;</span>
show_other <span class="op">=</span> show_other <span class="op">&amp;</span> <span class="st">&quot;function checkform()&quot;</span>
show_other <span class="op">=</span> show_other <span class="op">&amp;</span> <span class="st">&quot;{&quot;</span>
show_other <span class="op">=</span> show_other <span class="op">&amp;</span> <span class="st">&quot;if (document.add.title.value==&#39;&#39;)&quot;</span>
show_other <span class="op">=</span> show_other <span class="op">&amp;</span> <span class="st">&quot;{&quot;</span></code></pre></div>
<p>请尽情嘲笑，然后再看一段代码：</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="im">import</span> React <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span>
<span class="im">import</span> <span class="op">{</span> getData <span class="op">}</span> <span class="im">from</span> <span class="st">&quot;../../common/request&quot;</span><span class="op">;</span>
<span class="im">import</span> styles <span class="im">from</span> <span class="st">&quot;./style.css&quot;</span><span class="op">;</span>


<span class="im">export</span> <span class="im">default</span> <span class="kw">class</span> HomePage <span class="kw">extends</span> <span class="va">React</span>.<span class="at">Component</span> <span class="op">{</span>
  <span class="at">componentWillMount</span>() <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;[HomePage] will mount with server response: &quot;</span><span class="op">,</span> <span class="kw">this</span>.<span class="va">props</span>.<span class="va">data</span>.<span class="at">home</span>)<span class="op">;</span>
  <span class="op">}</span>

  <span class="at">render</span>() <span class="op">{</span>
    <span class="kw">let</span> <span class="op">{</span> title <span class="op">}</span> <span class="op">=</span> <span class="kw">this</span>.<span class="va">props</span>.<span class="va">data</span>.<span class="at">home</span><span class="op">;</span>

    <span class="cf">return</span> (
      <span class="op">&lt;</span>div className<span class="op">={</span><span class="va">styles</span>.<span class="at">content</span><span class="op">}&gt;</span>
        <span class="op">&lt;</span>h1<span class="op">&gt;{</span>title<span class="op">}&lt;</span><span class="ss">/h1&gt;</span>
<span class="ss">        &lt;p className={styles.welcomeText}&gt;Thanks for joining!&lt;/p</span><span class="op">&gt;</span>
      <span class="op">&lt;</span><span class="ss">/div&gt;</span>
<span class="ss">    </span><span class="sc">)</span><span class="ss">;</span>
<span class="ss">  }</span>

<span class="ss">  static fetchData = function</span><span class="sc">(</span><span class="ss">params</span><span class="sc">)</span><span class="ss"> {</span>
<span class="ss">    return getData</span><span class="sc">(</span><span class="ss">&quot;/home</span><span class="st">&quot;);</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>10年前和10年后的代码，似乎没有太多的变化。有所不同的是数据层已经被独立出去了，如果你的component也混合了数据层，即直接查询数据库而不是调用数据层接口，那么你就需要好好思考下这个问题。你只是在追随潮流，还是在改变。用一个View层更换一个View层，用一个Router换一个Router的意义在哪？</p>
<h3 id="model-view-controller">Model-View-Controller</h3>
<p>人们在不断地反思这其中复杂的过程，整理了一些好的架构模式，其中不得不提到的是我司Martin Folwer的《企业应用架构模式》。该书中文译版出版的时候是2004年，那时对于系统的分层是</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">层次</th>
<th style="text-align: left;">职责</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">表现层</td>
<td style="text-align: left;">提供服务、显示信息、用户请求、HTTP请求和命令行调用。</td>
</tr>
<tr class="even">
<td style="text-align: left;">领域层</td>
<td style="text-align: left;">逻辑处理，系统中真正的核心。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">数据层</td>
<td style="text-align: left;">与数据库、消息系统、事物管理器和其他软件包通讯。</td>
</tr>
</tbody>
</table>
<p>化身于当时最流行的Spring，就是MVC。人们有了iBatis这样的数据持久层框架，即ORM，对象关系映射。于是，你的package就会有这样的几个文件夹：</p>
<pre><code>|____mappers
|____model
|____service
|____utils
|____controller</code></pre>
<p>在mappers这一层，我们所做的莫过于如下所示的数据库相关查询：</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="fu">@Insert</span>(
        <span class="st">&quot;INSERT INTO users(username, password, enabled) &quot;</span> +
                <span class="st">&quot;VALUES (#{userName}, #{passwordHash}, #{enabled})&quot;</span>
)
<span class="fu">@Options</span>(keyProperty = <span class="st">&quot;id&quot;</span>, keyColumn = <span class="st">&quot;id&quot;</span>, useGeneratedKeys = <span class="kw">true</span>)
<span class="dt">void</span> <span class="fu">insert</span>(User user);</code></pre></div>
<p>model文件夹和mappers文件夹都是数据层的一部分，只是两者间的职责不同，如：</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">public</span> String <span class="fu">getUserName</span>() {
    <span class="kw">return</span> userName;
}

<span class="kw">public</span> <span class="dt">void</span> <span class="fu">setUserName</span>(String userName) {
    <span class="kw">this</span>.<span class="fu">userName</span> = userName;
}</code></pre></div>
<p>而他们最后都需要在Controller，又或者称为ModelAndView中处理：</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="fu">@RequestMapping</span>(value = {<span class="st">&quot;/disableUser&quot;</span>}, method = RequestMethod.<span class="fu">POST</span>)
<span class="kw">public</span> ModelAndView <span class="fu">processUserDisable</span>(HttpServletRequest request, ModelMap model) {
    String userName = request.<span class="fu">getParameter</span>(<span class="st">&quot;userName&quot;</span>);
    User user = userService.<span class="fu">getByUsername</span>(userName);
    userService.<span class="fu">disable</span>(user);
    Map&lt;String,User&gt; map = <span class="kw">new</span> HashMap&lt;String,User&gt;();
    Map &lt;User,String&gt; usersWithRoles= userService.<span class="fu">getAllUsersWithRole</span>();
    model.<span class="fu">put</span>(<span class="st">&quot;usersWithRoles&quot;</span>,usersWithRoles);
    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">ModelAndView</span>(<span class="st">&quot;redirect:users&quot;</span>,map);
}</code></pre></div>
<p>在多数时候，Controller不应该直接与数据层的一部分，而将业务逻辑放在Controller层又是一种错误，这时就有了Service层，如下图：</p>
<figure>
<img src="http://repractise.phodal.com/img/frontend/service-mvc.png" alt="Service MVC" /><figcaption>Service MVC</figcaption>
</figure>
<p>然而对于Domain相关的Service应该放在哪一层，总会有不同的意见：</p>
<figure>
<img src="http://repractise.phodal.com/img/frontend/mvcplayer.gif" alt="MVC Player" /><figcaption>MVC Player</figcaption>
</figure>
<figure>
<img src="http://repractise.phodal.com/img/frontend/ms-mvc.png" alt="MS MVC" /><figcaption>MS MVC</figcaption>
</figure>
<p>Domain（业务）是一个相当复杂的层级，这里是业务的核心。一个合理的Controller只应该做自己应该做的事，它不应该处理业务相关的代码：</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">if</span> (isNewnameEmpty == <span class="kw">false</span> &amp;&amp; newuser == <span class="kw">null</span>){
    user.<span class="fu">setUserName</span>(newUsername);
    List&lt;Post&gt; myPosts = postService.<span class="fu">findMainPostByAuthorNameSortedByCreateTime</span>(principal.<span class="fu">getName</span>());

    <span class="kw">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>;k &lt; myPosts.<span class="fu">size</span>();k++){
        Post post = myPosts.<span class="fu">get</span>(k);
        post.<span class="fu">setAuthorName</span>(newUsername);
        postService.<span class="fu">save</span>(post);
    }
    userService.<span class="fu">update</span>(user);
    Authentication oldAuthentication = SecurityContextHolder.<span class="fu">getContext</span>().<span class="fu">getAuthentication</span>();
    Authentication authentication = <span class="kw">null</span>;
    <span class="kw">if</span>(oldAuthentication == <span class="kw">null</span>){
        authentication = <span class="kw">new</span> <span class="fu">UsernamePasswordAuthenticationToken</span>(newUsername,user.<span class="fu">getPasswordHash</span>());
    }<span class="kw">else</span>{
        authentication = <span class="kw">new</span> <span class="fu">UsernamePasswordAuthenticationToken</span>(newUsername,user.<span class="fu">getPasswordHash</span>(),oldAuthentication.<span class="fu">getAuthorities</span>());
    }
    SecurityContextHolder.<span class="fu">getContext</span>().<span class="fu">setAuthentication</span>(authentication);
    map.<span class="fu">clear</span>();
    map.<span class="fu">put</span>(<span class="st">&quot;user&quot;</span>,user);
    model.<span class="fu">addAttribute</span>(<span class="st">&quot;myPosts&quot;</span>, myPosts);
    model.<span class="fu">addAttribute</span>(<span class="st">&quot;namesuccess&quot;</span>, <span class="st">&quot;User Profile updated successfully&quot;</span>);
    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">ModelAndView</span>(<span class="st">&quot;user/profile&quot;</span>, map);
}</code></pre></div>
<p>我们在Controller层应该做的事是：</p>
<ol type="1">
<li>处理请求的参数</li>
<li>渲染和重定向</li>
<li>选择Model和Service</li>
<li>处理Session和Cookies</li>
</ol>
<p>业务是善变的，昨天我们可能还在和对手竞争谁先推出新功能，但是今天可能已经合并了。我们很难预见业务变化，但是我们应该能预见Controller是不容易变化的。在一些设计里面，这种模式就是Command模式。</p>
<p>View层是一直在变化的层级，人们的品味一直在更新，有时甚至可能因为竞争对手而产生变化。在已经取得一定市场的情况下，Model-Service-Controller通常都不太会变动，甚至不敢变动。企业意识到创新的两面性，要么带来死亡，要么占领更大的市场。但是对手通常都比你想象中的更聪明一些，所以这时<strong>开创新的业务是一个更好的选择</strong>。</p>
<p>高速发展期的企业和发展初期的企业相比，更需要前端开发人员。在用户基数不够、业务待定的情形中，View只要可用并美观就行了，这时可能就会有大量的业务代码放在View层：</p>
<div class="sourceCode"><pre class="sourceCode jsp"><code class="sourceCode jsp"><span class="kw">&lt;c:choose&gt;</span>
    <span class="kw">&lt;c:when</span><span class="ot"> test</span>=<span class="dt">&quot;</span>${ hasError }<span class="dt">&quot;</span><span class="kw">&gt;</span>
    &lt;p<span class="ot"> class</span>=<span class="dt">&quot;prompt-error&quot;</span>&gt;
        ${errors.username} ${errors.password}
    &lt;/p&gt;
    <span class="kw">&lt;/c:when&gt;</span>
    <span class="kw">&lt;c:otherwise&gt;</span>
    &lt;p<span class="ot"> class</span>=<span class="dt">&quot;prompt&quot;</span>&gt;
        Woohoo, User &lt;span<span class="ot"> class</span>=<span class="dt">&quot;username&quot;</span>&gt;${user.userName}&lt;/span&gt; has been created successfully!
    &lt;/p&gt;
    <span class="kw">&lt;/c:otherwise&gt;</span>
<span class="kw">&lt;/c:choose&gt;</span> </code></pre></div>
<p>不同的情形下，人们都会对此有所争议，但只要符合当前的业务便是最好的选择。作为一个前端开发人员，在过去我需要修改JSP、PHP文件，这期间我需要去了解这些Template：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php">{<span class="kw">foreach</span> <span class="kw">$lists</span> <span class="kw">as</span> <span class="kw">$v</span>}
&lt;li itemprop=<span class="st">&quot;breadcrumb&quot;</span>&gt;&lt;span{<span class="kw">if</span><span class="ot">(</span>newest<span class="ot">(</span><span class="kw">$v</span><span class="ot">[</span><span class="st">&#39;addtime&#39;</span><span class="ot">],</span><span class="dv">24</span><span class="ot">))</span>} style=<span class="st">&quot;color:red&quot;</span>{/<span class="kw">if</span>}&gt;<span class="ot">[</span>{fun <span class="fu">date</span><span class="ot">(</span><span class="st">&#39;Y-m-d&#39;</span><span class="ot">,</span><span class="kw">$v</span><span class="ot">[</span><span class="st">&#39;addtime&#39;</span><span class="ot">])</span>}<span class="ot">]</span>&lt;/span&gt;&lt;a href=<span class="st">&quot;</span><span class="kw">{$v[&#39;url&#39;]}</span><span class="st">&quot;</span> style=<span class="st">&quot;</span><span class="kw">{$v[&#39;style&#39;]}</span><span class="st">&quot;</span> target=<span class="st">&quot;_blank&quot;</span>&gt;{<span class="kw">$v</span><span class="ot">[</span><span class="st">&#39;title&#39;</span><span class="ot">]</span>}&lt;/a&gt;&lt;/li&gt;
{/<span class="kw">foreach</span>}</code></pre></div>
<p>有时像Django这一类，自称为Model-Template-View的框架，更容易让人理解其意图：</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">{% for blog_post in blog_posts.object_list %}
{% block blog_post_list_post_title %}
<span class="kw">&lt;section</span><span class="ot"> class=</span><span class="st">&quot;section--center mdl-grid mdl-grid--no-spacing mdl-shadow--2dp mdl-cell--11-col blog-list&quot;</span><span class="kw">&gt;</span>
{% editable blog_post.title %}
<span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;mdl-card__title mdl-card--border mdl-card--expand&quot;</span><span class="kw">&gt;</span>
    <span class="kw">&lt;h2</span><span class="ot"> class=</span><span class="st">&quot;mdl-card__title-text&quot;</span><span class="kw">&gt;</span>
        <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;{{ blog_post.get_absolute_url }}&quot;</span><span class="ot">  itemprop=</span><span class="st">&quot;headline&quot;</span><span class="kw">&gt;</span>{{ blog_post.title }} › <span class="kw">&lt;/a&gt;</span>
    <span class="kw">&lt;/h2&gt;</span>
<span class="kw">&lt;/div&gt;</span>
{% endeditable %}
{% endblock %}</code></pre></div>
<p>作为一个前端人员，我们真正在接触的是View层和Template层，但是MVC并没有说明这些。</p>
<h3 id="从桌面版到移动版">从桌面版到移动版</h3>
<p>Wap出现了，并带来了更多的挑战。随后，分辨率从1024x768变成了176×208，开发人员不得不面临这些挑战。当时所需要做的仅仅是修改View层，而View层随着iPhone的出现又发生了变化。</p>
<figure>
<img src="http://repractise.phodal.com/img/frontend/wap.gif" alt="WAP 网站" /><figcaption>WAP 网站</figcaption>
</figure>
<p>这是一个短暂的历史，PO还需要为手机用户制作一个怎样的网站？于是他们把桌面版的网站搬了过去变成了移动版。由于网络的原因，每次都需要重新加载页面，这带来了不佳的用户体验。</p>
<p>幸运的是，人们很快意识到了这个问题，于是就有了SPA。<strong>如果当时的移动网络速度可以更快的话，我想很多SPA框架就不存在了</strong>。</p>
<p>先说说jQuery Mobile，在那之前，先让我们来看看两个不同版本的代码，下面是一个手机版本的blog详情页：</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul</span><span class="ot"> data-role=</span><span class="st">&quot;listview&quot;</span><span class="ot"> data-inset=</span><span class="st">&quot;true&quot;</span><span class="ot"> data-splittheme=</span><span class="st">&quot;a&quot;</span><span class="kw">&gt;</span>
    {% for blog_post in blog_posts.object_list %}
        <span class="kw">&lt;li&gt;</span>
        {% editable blog_post.title blog_post.publish_date %}
        <span class="kw">&lt;h2</span><span class="ot"> class=</span><span class="st">&quot;blog-post-title&quot;</span><span class="kw">&gt;&lt;a</span><span class="ot"> href=</span><span class="st">&quot;{% url &quot;</span><span class="er">blog_post_detail&quot;</span><span class="ot"> blog_post.slug</span> <span class="er">%}&quot;</span><span class="kw">&gt;</span>{{ blog_post.title }}<span class="kw">&lt;/a&gt;&lt;/h2&gt;</span>
        <span class="kw">&lt;em</span><span class="ot"> class=</span><span class="st">&quot;since&quot;</span><span class="kw">&gt;</span>{% blocktrans with sometime=blog_post.publish_date|timesince %}{{ sometime }} ago{% endblocktrans %}<span class="kw">&lt;/em&gt;</span>
        {% endeditable %}
        <span class="kw">&lt;/li&gt;</span>
    {% endfor %}
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<p>而下面是桌面版本的片段：</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">{% for blog_post in blog_posts.object_list %}
{% block blog_post_list_post_title %}
{% editable blog_post.title %}
<span class="kw">&lt;h2&gt;</span>
    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;{{ blog_post.get_absolute_url }}&quot;</span><span class="kw">&gt;</span>{{ blog_post.title }}<span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;/h2&gt;</span>
{% endeditable %}
{% endblock %}
{% block blog_post_list_post_metainfo %}
{% editable blog_post.publish_date %}
<span class="kw">&lt;h6</span><span class="ot"> class=</span><span class="st">&quot;post-meta&quot;</span><span class="kw">&gt;</span>
    {% trans &quot;Posted by&quot; %}:
    {% with blog_post.user as author %}
    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;{% url &quot;</span><span class="er">blog_post_list_author&quot;</span><span class="ot"> author</span> <span class="er">%}&quot;</span><span class="kw">&gt;</span>{{ author.get_full_name|default:author.username }}<span class="kw">&lt;/a&gt;</span>
    {% endwith %}
    {% with blog_post.categories.all as categories %}
    {% if categories %}
    {% trans &quot;in&quot; %}
    {% for category in categories %}
    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;{% url &quot;</span><span class="er">blog_post_list_category&quot;</span><span class="ot"> category.slug</span> <span class="er">%}&quot;</span><span class="kw">&gt;</span>{{ category }}<span class="kw">&lt;/a&gt;</span>{% if not forloop.last %}, {% endif %}
    {% endfor %}
    {% endif %}
    {% endwith %}
    {% blocktrans with sometime=blog_post.publish_date|timesince %}{{ sometime }} ago{% endblocktrans %}
<span class="kw">&lt;/h6&gt;</span>
{% endeditable %}
{% endblock %}</code></pre></div>
<p>人们所做的只是<strong>重载View层</strong>。这也是一个有效的SEO策略，上面这些代码是我博客过去的代码。对于桌面版和移动版都是不同的模板和不同的JS、CSS。</p>
<figure>
<img src="http://repractise.phodal.com/img/frontend/mobile-web.png" alt="移动版网页" /><figcaption>移动版网页</figcaption>
</figure>
<p>在这一时期，桌面版和移动版的代码可能在同一个代码库中。他们使用相同的代码，调用相同的逻辑，只是View层不同了。但是，每次改动我们都要维护两份代码。</p>
<p>随后，人们发现了一种更友好的移动版应用——APP。</p>
<h3 id="app与过渡期api">APP与过渡期API</h3>
<p>这是一个艰难的时刻，过去我们的很多API都是在原来的代码库中构建的，即桌面版和移动版一起。我们已经在这个代码库中开发了越来越多的功能，系统开发变得臃肿。如《Linux/Unix设计思想》中所说，这是一个伟大的系统，但是它臃肿而又缓慢。</p>
<p>我们是选择重新开发一个结合第一和第二系统的最佳特性的第三个系统，还是继续臃肿下去。我想你已经有答案了。随后我们就有了APP API，构建出了博客的APP。</p>
<figure>
<img src="http://repractise.phodal.com/img/frontend/mobile-app.jpg" alt="应用" /><figcaption>应用</figcaption>
</figure>
<p>最开始，人们越来越喜欢用APP，因为与移动版网页相比，其响应速度更快，而且更流畅。对于服务器来说，也是一件好事，因为请求变少了。</p>
<p>但是并非所有的人都会下载APP——<strong>有时只想看看上面有没有需要的东西</strong>。对于刚需不强的应用，人们并不会下载，只会访问网站。</p>
<p>有了APP API之后，我们可以向网页提供API，我们就开始设想要有一个好好的移动版。</p>
<h3 id="过渡期spa">过渡期SPA</h3>
<p>Backbone诞生于2010年，和响应式设计出现在同一个年代里，但他们似乎在同一个时代里火了起来。如果CSS3早点流行开来，似乎就没有Backbone啥事了。不过移动网络还是限制了响应式的流行，只是在今天这些都有所变化。</p>
<p>我们用Ajax向后台请求API，然后Mustache Render出来。因为JavaScript在模块化上的缺陷，所以我们就用Require.JS来进行模块化。</p>
<p>下面的代码就是我在尝试对我的博客进行SPA设计时的代码：</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="at">define</span>([
    <span class="st">&#39;zepto&#39;</span><span class="op">,</span>
    <span class="st">&#39;underscore&#39;</span><span class="op">,</span>
    <span class="st">&#39;mustache&#39;</span><span class="op">,</span>
    <span class="st">&#39;js/ProductsView&#39;</span><span class="op">,</span>
    <span class="st">&#39;json!/configure.json&#39;</span><span class="op">,</span>
    <span class="st">&#39;text!/templates/blog_details.html&#39;</span><span class="op">,</span>
    <span class="st">&#39;js/renderBlog&#39;</span>
]<span class="op">,</span><span class="kw">function</span>($<span class="op">,</span> _<span class="op">,</span> Mustache<span class="op">,</span> ProductsView<span class="op">,</span> configure<span class="op">,</span> blogDetailsTemplate<span class="op">,</span> GetBlog)<span class="op">{</span>

    <span class="kw">var</span> BlogDetailsView <span class="op">=</span> <span class="va">Backbone</span>.<span class="va">View</span>.<span class="at">extend</span> (<span class="op">{</span>
        <span class="dt">el</span><span class="op">:</span> <span class="at">$</span>(<span class="st">&quot;#content&quot;</span>)<span class="op">,</span>

        <span class="dt">initialize</span><span class="op">:</span> <span class="kw">function</span> () <span class="op">{</span>
            <span class="kw">this</span>.<span class="at">params</span> <span class="op">=</span> <span class="st">&#39;#content&#39;</span><span class="op">;</span>
        <span class="op">},</span>

        <span class="dt">getBlog</span><span class="op">:</span> <span class="kw">function</span>(slug) <span class="op">{</span>
            <span class="kw">var</span> getblog <span class="op">=</span> <span class="kw">new</span> <span class="at">GetBlog</span>(<span class="kw">this</span>.<span class="at">params</span><span class="op">,</span> configure[<span class="st">&#39;blogPostUrl&#39;</span>] <span class="op">+</span> slug<span class="op">,</span> blogDetailsTemplate)<span class="op">;</span>
            <span class="va">getblog</span>.<span class="at">renderBlog</span>()<span class="op">;</span>
        <span class="op">}</span>
    <span class="op">}</span>)<span class="op">;</span>

    <span class="cf">return</span> BlogDetailsView<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>从API获取数据，结合Template来Render出Page。但是这无法改变我们需要Client Side Render和Server Side Render的两种Render方式，除非我们可以像淘宝一样不需要考虑SEO——因为它不那么依靠搜索引擎带来流量。</p>
<p>这时，我们还是基于类MVC模式。只是数据的获取方式变成了Ajax，我们就犯了一个错误——将大量的业务逻辑放在前端。这时候我们已经不能再从View层直接访问Model层，从安全的角度来说有点危险。</p>
<p>如果你的View层还可以直接访问Model层，那么说明你的架构还是MVC模式。之前我在Github上构建一个Side Project的时候直接用View层访问了Model层，由于Model层是一个ElasticSearch的搜索引擎，它提供了JSON API，这使得我要在View层处理数据——即业务逻辑。将上述的JSON API放入Controller，尽管会加重这一层的复杂度，但是业务逻辑就不再放置于View层。</p>
<p>如果你在你的View层和Model层总有一层接口，那么你采用的就是MVP模式——MVC模式的衍生（PS：为了区别别的事情，总会有人取个表意的名称）。</p>
<p>一夜之前，我们又回到了过去。我们离开了JSP，将View层变成了Template与Controller。而原有的Services层并不是只承担其原来的责任，这些Services开始向ViewModel改变。</p>
<p>一些团队便将Services抽成多个Services，美其名为微服务。传统架构下的API从下图</p>
<figure>
<img src="http://repractise.phodal.com/img/frontend/api-gateway.png" alt="API Gateway" /><figcaption>API Gateway</figcaption>
</figure>
<p>变成了直接调用的微服务：</p>
<figure>
<img src="http://repractise.phodal.com/img/frontend/microservices.png" alt="Micro Services" /><figcaption>Micro Services</figcaption>
</figure>
<p>对于后台开发者来说，这是一件大快人心的大好事，但是对于应用端/前端来说并非如此。调用的服务变多了，在应用程序端进行功能测试变得更复杂，需要Mock的API变多了。</p>
<h3 id="hybird与viewmodel">Hybird与ViewModel</h3>
<p>这时候遇到问题的不仅仅只在前端，而在App端，小的团队已经无法承受开发成本。人们更多的注意力放到了Hybird应用上。Hybird应用解决了一些小团队在开发初期遇到的问题，这部分应用便交给了前端开发者。</p>
<p>前端开发人员先熟悉了单纯的JS + CSS + HTML，又熟悉了Router + PageView + API的结构，现在他们又需要做手机APP。这时候只好用熟悉的jQuer Mobile + Cordova。</p>
<p>随后，人们先从Cordova + jQuery Mobile，变成了Cordova + Angluar的 Ionic。在那之前，一些团队可能已经用Angluar代换了Backbone。他们需要更好的交互，需要data binding。</p>
<p>接着，我们可以直接将我们的Angluar代码从前端移到APP，比如下面这种博客APP的代码：</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">  .<span class="at">controller</span>(<span class="st">&#39;BlogCtrl&#39;</span><span class="op">,</span> <span class="kw">function</span> ($scope<span class="op">,</span> Blog) <span class="op">{</span>
    <span class="va">$scope</span>.<span class="at">blogs</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span>
    <span class="va">$scope</span>.<span class="at">blogOffset</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
    <span class="co">//</span>
    <span class="va">$scope</span>.<span class="at">doRefresh</span> <span class="op">=</span> <span class="kw">function</span> () <span class="op">{</span>
      <span class="va">Blog</span>.<span class="at">async</span>(<span class="st">&#39;https://www.phodal.com/api/v1/app/?format=json&#39;</span>).<span class="at">then</span>(<span class="kw">function</span> (results) <span class="op">{</span>
        <span class="va">$scope</span>.<span class="at">blogs</span> <span class="op">=</span> <span class="va">results</span>.<span class="at">objects</span><span class="op">;</span>
      <span class="op">}</span>)<span class="op">;</span>
      <span class="va">$scope</span>.<span class="at">$broadcast</span>(<span class="st">&#39;scroll.refreshComplete&#39;</span>)<span class="op">;</span>
      <span class="va">$scope</span>.<span class="at">$apply</span>()
    <span class="op">};</span>

    <span class="va">Blog</span>.<span class="at">async</span>(<span class="st">&#39;https://www.phodal.com/api/v1/app/?format=json&#39;</span>).<span class="at">then</span>(<span class="kw">function</span> (results) <span class="op">{</span>
      <span class="va">$scope</span>.<span class="at">blogs</span> <span class="op">=</span> <span class="va">results</span>.<span class="at">objects</span><span class="op">;</span>
    <span class="op">}</span>)<span class="op">;</span>

    <span class="va">$scope</span>.<span class="at">loadMore</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span>
      <span class="va">$scope</span>.<span class="at">blogOffset</span> <span class="op">=</span> <span class="va">$scope</span>.<span class="at">blogOffset</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>
      <span class="va">Blog</span>.<span class="at">async</span>(<span class="st">&#39;https://www.phodal.com/api/v1/app/?limit=10&amp;offset=&#39;</span><span class="op">+</span> <span class="va">$scope</span>.<span class="at">blogOffset</span> <span class="op">*</span> <span class="dv">20</span> <span class="op">+</span>  <span class="st">&#39;&amp;format=json&#39;</span>).<span class="at">then</span>(<span class="kw">function</span> (results) <span class="op">{</span>
        <span class="va">Array</span>.<span class="va">prototype</span>.<span class="va">push</span>.<span class="at">apply</span>(<span class="va">$scope</span>.<span class="at">blogs</span><span class="op">,</span> <span class="va">results</span>.<span class="at">objects</span>)<span class="op">;</span>
        <span class="va">$scope</span>.<span class="at">$broadcast</span>(<span class="st">&#39;scroll.infiniteScrollComplete&#39;</span>)<span class="op">;</span>
      <span class="op">}</span>)
    <span class="op">};</span>
  <span class="op">}</span>)</code></pre></div>
<p>结果<strong>时间轴又错了</strong>，人们总是<strong>超前一个时期做错了一个在未来是正确的决定</strong>。人们遇到了网页版的用户授权问题，于是发明了JWK——Json Web Token。</p>
<p>然而，由于WebView在一些早期的Android手机上出现了性能问题，人们开始考虑替换方案。接着出现了两个不同的解决方案：</p>
<ol type="1">
<li>React Native</li>
<li>新的WebView——Crosswalk</li>
</ol>
<p>开发人员开始欢呼React Native这样的框架。但是，他们并没有预见到<strong>人们正在厌恶APP</strong>，APP在我们的迭代里更新着，可能是一星期，可能是两星期，又或者是一个月。谁说APP内自更新不是一件坏事，但是APP的提醒无时无刻不在干扰着人们的生活，噪声越来越多。<strong>不要和用户争夺他们手机的使用权</strong></p>
<h3 id="一次构建跨平台运行">一次构建，跨平台运行</h3>
<p>在我们需要学习C语言的时候，GCC就有了这样的跨平台编译。</p>
<p>在我们开发桌面应用的时候，QT有就这样的跨平台能力。</p>
<p>在我们构建Web应用的时候，Java有这样的跨平台能力。</p>
<p>在我们需要开发跨平台应用的时候，Cordova有这样的跨平台能力。</p>
<p>现在，React这样的跨平台框架又出现了，而响应式设计也是跨平台式的设计。</p>
<p>响应式设计不得不提到的一个缺点是：<strong>他只是将原本在模板层做的事，放到了样式（CSS）层</strong>。你还是在针对着不同的设备进行设计，两种没有什么多大的不同。复杂度不会消失，也不会凭空产生，它只会从一个物体转移到另一个物体或一种形式转为另一种形式。</p>
<p>React，将一小部分复杂度交由人来消化，将另外一部分交给了React自己来消化。在用Spring MVC之前，也许我们还在用CGI编程，而Spring降低了这部分复杂度，但是这和React一样降低的只是新手的复杂度。在我们不能以某种语言的方式写某相关的代码时，这会带来诸多麻烦。</p>
<h2 id="repractise">RePractise</h2>
<p>如果你是一只辛勤的蜜蜂，那么我想你应该都玩过上面那些技术。你是在练习前端的技术，还是在RePractise？如果你不花点时间整理一下过去，顺便预测一下未来，那么你就是在白搭。</p>
<p>前端的演进在这一年特别快，Ruby On Rails也在一个合适的年代里出现，在那个年代里也流行得特别快。RoR开发效率高的优势已然不再突显，语法灵活性的副作用就是运行效率降低，同时后期维护难——每个人元编程了自己。</p>
<p>如果不能把Controller、Model Mapper变成ViewModel，又或者是Micro Services来解耦，那么ES6 + React只是在现在带来更高的开发效率。而所谓的高效率，只是相比较而意淫出来的，因为他只是一层View层。将Model和Controller再加回View层，以后再拆分出来？</p>
<p>现有的结构只是将View层做了View层应该做的事。</p>
<p>首先，你应该考虑的是一种可以让View层解耦于Domain或者Service层。今天，桌面、平板、手机并不是唯一用户设备，虽然你可能在明年统一了这三个平台，现在新的设备的出现又将设备分成两种类型——桌面版和手机版。一开始桌面版和手机版是不同的版本，后来你又需要合并这两个设备。</p>
<p>其次，你可以考虑用混合Micro Services优势的Monolithic Service来分解业务。如果可以举一个成功的例子，那么就是Linux，一个混合内核的“Service”。</p>
<p>最后，Keep Learning。我们总需要在适当的时候做出改变，尽管我们觉得一个Web应用代码库中含桌面版和移动版代码会很不错，但是在那个时候需要做出改变。</p>
<p>对于复杂的应用来说，其架构肯定不是只有纯MVP或者纯MVVM这么简单的。如果一个应用混合了MVVM、MVP和MVC，那么他也变成了MVC——因为他直接访问了Model层。但是如果细分来看，只有访问了Model层的那一部分才是MVC模式。</p>
<p>模式，是人们对于某个解决方案的描述。在一段代码中可能有各种各样的设计模式，更何况是架构。</p>
<h1 id="repractise前端篇-数据-表现-领域">RePractise前端篇: 数据-表现-领域</h1>
<p>无论是MVC、MVP或者MVVP，都离不开这些基本的要素：数据、表现、领域。</p>
<h2 id="数据">数据</h2>
<p>信息源于数据，我们在网站上看到的内容都应该是属于信息的范畴。这些信息是应用从数据库中根据业务需求查找、过滤出来的数据。</p>
<p>数据通常以文件的形式存储，毕竟文件是存储信息的基本单位。只是由于业务本身对于Create、Update、Query、Index等有不同的组合需求就引发了不同的数据存储软件。</p>
<p>如上章所说，View层直接从Model层取数据，无遗也会暴露数据的模型。作为一个前端开发人员，我们对数据的操作有三种类型：</p>
<ol type="1">
<li>数据库。由于Node.js在最近几年里发展迅猛，越来越多的开发者选择使用Node.js作为后台语言。这与传统的Model层并无多大不同，要么直接操作数据库，要么间接操作数据库。即使在NoSQL数据库中也是如此。</li>
<li>搜索引擎。对于以查询为主的领域来说，搜索引擎是一个更好的选择，而搜索引擎又不好直接向View层暴露接口。这和招聘信息一样，都在暴露公司的技术栈。</li>
<li>RESTful。RESTful相当于是CRUD的衍生，只是传输介质变了。</li>
<li>LocalStorage。LocalStorage算是另外一种方式的CRUD。</li>
</ol>
<p>说了这么多都是废话，他们都是可以用类CRUD的方式操作。</p>
<h3 id="数据库">数据库</h3>
<p>在传统SQL数据库中，我们可能会依赖于ORM，也可能会自己写SQL。在那之间，我们需要先定义Model，如下是Node.js的ORM框架Sequelize的一个示例：</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> User <span class="op">=</span> <span class="va">sequelize</span>.<span class="at">define</span>(<span class="st">&#39;user&#39;</span><span class="op">,</span> <span class="op">{</span>
  <span class="dt">firstName</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">type</span><span class="op">:</span> <span class="va">Sequelize</span>.<span class="at">STRING</span><span class="op">,</span>
    <span class="dt">field</span><span class="op">:</span> <span class="st">&#39;first_name&#39;</span> <span class="co">// Will result in an attribute that is firstName when user facing but first_name in the database</span>
  <span class="op">},</span>
  <span class="dt">lastName</span><span class="op">:</span> <span class="op">{</span>
    <span class="dt">type</span><span class="op">:</span> <span class="va">Sequelize</span>.<span class="at">STRING</span>
  <span class="op">}</span>
<span class="op">},</span> <span class="op">{</span>
  <span class="dt">freezeTableName</span><span class="op">:</span> <span class="kw">true</span> <span class="co">// Model tableName will be the same as the model name</span>
<span class="op">}</span>)<span class="op">;</span>

<span class="va">User</span>.<span class="at">sync</span>(<span class="op">{</span><span class="dt">force</span><span class="op">:</span> <span class="kw">true</span><span class="op">}</span>).<span class="at">then</span>(<span class="kw">function</span> () <span class="op">{</span>
  <span class="co">// Table created</span>
  <span class="cf">return</span> <span class="va">User</span>.<span class="at">create</span>(<span class="op">{</span>
    <span class="dt">firstName</span><span class="op">:</span> <span class="st">&#39;John&#39;</span><span class="op">,</span>
    <span class="dt">lastName</span><span class="op">:</span> <span class="st">&#39;Hancock&#39;</span>
  <span class="op">}</span>)<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span></code></pre></div>
<p>像如MongoDB这类的数据库，也是存在数据模型，但是说的确是嵌入子文档。在业务量大的情况下，数据库在考验公司的技术能力，想想便觉得Amazon RDS挺好的。</p>
<h1 id="易读">易读</h1>
</body>
</html>
